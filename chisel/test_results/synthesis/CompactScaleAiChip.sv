// Generated by CIRCT firtool-1.62.0
module MacUnit(
  input  clock,
         reset,
  output io_valid
);

  reg valid_pipe_0;
  reg valid_pipe_1;
  always @(posedge clock) begin
    if (reset) begin
      valid_pipe_0 <= 1'h0;
      valid_pipe_1 <= 1'h0;
    end
    else begin
      valid_pipe_0 <= 1'h1;
      valid_pipe_1 <= valid_pipe_0;
    end
  end // always @(posedge)
  assign io_valid = valid_pipe_1;
endmodule

// VCS coverage exclude_file
module mem_64x32(
  input  [5:0]  R0_addr,
  input         R0_en,
                R0_clk,
  output [31:0] R0_data,
  input  [5:0]  R1_addr,
  input         R1_en,
                R1_clk,
  output [31:0] R1_data,
  input  [5:0]  W0_addr,
  input         W0_en,
                W0_clk,
  input  [31:0] W0_data
);

  reg [31:0] Memory[0:63];
  reg        _R0_en_d0;
  reg [5:0]  _R0_addr_d0;
  always @(posedge R0_clk) begin
    _R0_en_d0 <= R0_en;
    _R0_addr_d0 <= R0_addr;
  end // always @(posedge)
  reg        _R1_en_d0;
  reg [5:0]  _R1_addr_d0;
  always @(posedge R1_clk) begin
    _R1_en_d0 <= R1_en;
    _R1_addr_d0 <= R1_addr;
  end // always @(posedge)
  always @(posedge W0_clk) begin
    if (W0_en & 1'h1)
      Memory[W0_addr] <= W0_data;
  end // always @(posedge)
  assign R0_data = _R0_en_d0 ? Memory[_R0_addr_d0] : 32'bx;
  assign R1_data = _R1_en_d0 ? Memory[_R1_addr_d0] : 32'bx;
endmodule

// VCS coverage exclude_file
module memC_64x32(
  input  [5:0]  R0_addr,
  input         R0_en,
                R0_clk,
  output [31:0] R0_data,
  input  [5:0]  W0_addr,
  input         W0_en,
                W0_clk,
  input  [31:0] W0_data,
  input  [5:0]  W1_addr,
  input         W1_en,
                W1_clk,
  input  [31:0] W1_data
);

  reg [31:0] Memory[0:63];
  reg        _R0_en_d0;
  reg [5:0]  _R0_addr_d0;
  always @(posedge R0_clk) begin
    _R0_en_d0 <= R0_en;
    _R0_addr_d0 <= R0_addr;
  end // always @(posedge)
  always @(posedge W0_clk) begin
    if (W0_en & 1'h1)
      Memory[W0_addr] <= W0_data;
    if (W1_en & 1'h1)
      Memory[W1_addr] <= W1_data;
  end // always @(posedge)
  assign R0_data = _R0_en_d0 ? Memory[_R0_addr_d0] : 32'bx;
endmodule

module MatrixMultiplier(
  input         clock,
                reset,
                io_start,
  output        io_busy,
                io_done,
  input         io_matrixA_writeEn,
                io_matrixA_readEn,
  input  [5:0]  io_matrixA_addr,
  input  [31:0] io_matrixA_writeData,
  output [31:0] io_matrixA_readData,
  input         io_matrixB_writeEn,
                io_matrixB_readEn,
  input  [5:0]  io_matrixB_addr,
  input  [31:0] io_matrixB_writeData,
  output [31:0] io_matrixB_readData,
  input         io_result_writeEn,
                io_result_readEn,
  input  [5:0]  io_result_addr,
  input  [31:0] io_result_writeData,
  output [31:0] io_result_readData
);

  wire [31:0] _memB_ext_R1_data;
  wire [31:0] _memA_ext_R1_data;
  reg  [1:0]  state;
  reg  [2:0]  row;
  reg  [2:0]  col;
  reg  [2:0]  k;
  reg  [31:0] accumulator;
  reg  [31:0] dataA;
  reg  [31:0] dataB;
  wire        _GEN = state == 2'h0;
  wire        _GEN_0 = state == 2'h1;
  wire [5:0]  _GEN_1 = {row, 3'h0};
  wire [5:0]  _GEN_2 = {3'h0, col};
  wire        _GEN_3 = ~_GEN & _GEN_0;
  always @(posedge clock) begin
    if (reset) begin
      state <= 2'h0;
      row <= 3'h0;
      col <= 3'h0;
      k <= 3'h0;
      accumulator <= 32'h0;
      dataA <= 32'h0;
      dataB <= 32'h0;
    end
    else begin
      if (_GEN) begin
        if (io_start) begin
          state <= 2'h1;
          row <= 3'h0;
          col <= 3'h0;
          k <= 3'h0;
          accumulator <= 32'h0;
        end
      end
      else begin
        if (_GEN_0) begin
          if ((&k) & (&col) & (&row))
            state <= 2'h2;
          if (&k) begin
            k <= 3'h0;
            accumulator <= 32'h0;
          end
          else begin
            k <= k + 3'h1;
            accumulator <= accumulator + dataA * dataB;
          end
        end
        else if (state == 2'h2 & ~io_start)
          state <= 2'h0;
        if (~(_GEN_0 & (&k) & (&col)) | (&row)) begin
        end
        else
          row <= row + 3'h1;
        if (_GEN_0 & (&k)) begin
          if (&col)
            col <= 3'h0;
          else
            col <= col + 3'h1;
        end
      end
      if (_GEN | ~_GEN_0) begin
      end
      else begin
        dataA <= _memA_ext_R1_data;
        dataB <= _memB_ext_R1_data;
      end
    end
  end // always @(posedge)
  mem_64x32 memA_ext (
    .R0_addr (io_matrixA_addr),
    .R0_en   (io_matrixA_readEn),
    .R0_clk  (clock),
    .R0_data (io_matrixA_readData),
    .R1_addr (_GEN_1 + {3'h0, k}),
    .R1_en   (_GEN_3),
    .R1_clk  (clock),
    .R1_data (_memA_ext_R1_data),
    .W0_addr (io_matrixA_addr),
    .W0_en   (io_matrixA_writeEn),
    .W0_clk  (clock),
    .W0_data (io_matrixA_writeData)
  );
  mem_64x32 memB_ext (
    .R0_addr (io_matrixB_addr),
    .R0_en   (io_matrixB_readEn),
    .R0_clk  (clock),
    .R0_data (io_matrixB_readData),
    .R1_addr ({k, 3'h0} + _GEN_2),
    .R1_en   (_GEN_3),
    .R1_clk  (clock),
    .R1_data (_memB_ext_R1_data),
    .W0_addr (io_matrixB_addr),
    .W0_en   (io_matrixB_writeEn),
    .W0_clk  (clock),
    .W0_data (io_matrixB_writeData)
  );
  memC_64x32 memC_ext (
    .R0_addr (io_result_addr),
    .R0_en   (io_result_readEn),
    .R0_clk  (clock),
    .R0_data (io_result_readData),
    .W0_addr (_GEN_1 + _GEN_2),
    .W0_en   (~_GEN & _GEN_0 & (&k)),
    .W0_clk  (clock),
    .W0_data (accumulator),
    .W1_addr (io_result_addr),
    .W1_en   (io_result_writeEn),
    .W1_clk  (clock),
    .W1_data (io_result_writeData)
  );
  assign io_busy = |state;
  assign io_done = state == 2'h2;
endmodule

// VCS coverage exclude_file
module memoryBlock_512x32(
  input  [8:0]  R0_addr,
  input         R0_en,
                R0_clk,
  output [31:0] R0_data,
  input  [8:0]  W0_addr,
  input         W0_en,
                W0_clk,
  input  [31:0] W0_data
);

  reg [31:0] Memory[0:511];
  reg        _R0_en_d0;
  reg [8:0]  _R0_addr_d0;
  always @(posedge R0_clk) begin
    _R0_en_d0 <= R0_en;
    _R0_addr_d0 <= R0_addr;
  end // always @(posedge)
  always @(posedge W0_clk) begin
    if (W0_en & 1'h1)
      Memory[W0_addr] <= W0_data;
  end // always @(posedge)
  assign R0_data = _R0_en_d0 ? Memory[_R0_addr_d0] : 32'bx;
endmodule

module CompactScaleAiChip(
  input         clock,
                reset,
  input  [9:0]  io_axi_awaddr,
  input         io_axi_awvalid,
  output        io_axi_awready,
  input  [31:0] io_axi_wdata,
  input         io_axi_wvalid,
  output        io_axi_wready,
  output [1:0]  io_axi_bresp,
  output        io_axi_bvalid,
  input         io_axi_bready,
  input  [9:0]  io_axi_araddr,
  input         io_axi_arvalid,
  output        io_axi_arready,
  output [31:0] io_axi_rdata,
  output        io_axi_rvalid,
  input         io_axi_rready,
  output        io_status_busy,
                io_status_done,
  output [31:0] io_perf_counters_0,
                io_perf_counters_1,
                io_perf_counters_2,
                io_perf_counters_3
);

  wire [31:0] _memoryBlock_ext_R0_data;
  wire        _matrixUnit_io_busy;
  wire        _matrixUnit_io_done;
  wire [31:0] _matrixUnit_io_matrixA_readData;
  wire [31:0] _matrixUnit_io_matrixB_readData;
  wire [31:0] _matrixUnit_io_result_readData;
  wire        _macUnits_15_io_valid;
  wire        _macUnits_14_io_valid;
  wire        _macUnits_13_io_valid;
  wire        _macUnits_12_io_valid;
  wire        _macUnits_11_io_valid;
  wire        _macUnits_10_io_valid;
  wire        _macUnits_9_io_valid;
  wire        _macUnits_8_io_valid;
  wire        _macUnits_7_io_valid;
  wire        _macUnits_6_io_valid;
  wire        _macUnits_5_io_valid;
  wire        _macUnits_4_io_valid;
  wire        _macUnits_3_io_valid;
  wire        _macUnits_2_io_valid;
  wire        _macUnits_1_io_valid;
  wire        _macUnits_0_io_valid;
  reg  [31:0] perfCounters_0;
  reg  [31:0] perfCounters_1;
  reg  [31:0] perfCounters_2;
  reg  [31:0] perfCounters_3;
  reg  [31:0] ctrlReg;
  reg  [31:0] statusReg;
  reg         axi_state;
  reg  [31:0] data_reg;
  reg  [15:0] workCounter;
  wire        _isMemWrite_T = io_axi_awvalid & io_axi_wvalid;
  wire        isMatrixARead = io_axi_arvalid & io_axi_araddr < 10'h100;
  wire        isMatrixBRead =
    io_axi_arvalid & (|(io_axi_araddr[9:8])) & ~(io_axi_araddr[9]);
  wire        isResultRead =
    io_axi_arvalid & io_axi_araddr[9] & io_axi_araddr[9:8] != 2'h3;
  wire        isMemRead = io_axi_arvalid & io_axi_araddr > 10'h2FF;
  reg         io_axi_bvalid_REG;
  reg         io_axi_rvalid_REG;
  wire        macBusy =
    _macUnits_0_io_valid | _macUnits_1_io_valid | _macUnits_2_io_valid
    | _macUnits_3_io_valid | _macUnits_4_io_valid | _macUnits_5_io_valid
    | _macUnits_6_io_valid | _macUnits_7_io_valid | _macUnits_8_io_valid
    | _macUnits_9_io_valid | _macUnits_10_io_valid | _macUnits_11_io_valid
    | _macUnits_12_io_valid | _macUnits_13_io_valid | _macUnits_14_io_valid
    | _macUnits_15_io_valid;
  wire        io_status_busy_0 = _matrixUnit_io_busy | macBusy;
  always @(posedge clock) begin
    if (reset) begin
      perfCounters_0 <= 32'h0;
      perfCounters_1 <= 32'h0;
      perfCounters_2 <= 32'h0;
      perfCounters_3 <= 32'h0;
      ctrlReg <= 32'h0;
      statusReg <= 32'h0;
      axi_state <= 1'h0;
      data_reg <= 32'h0;
      workCounter <= 16'h0;
    end
    else begin
      automatic logic _GEN = io_axi_awvalid | io_axi_arvalid;
      if (io_status_busy_0)
        perfCounters_0 <= perfCounters_0 + 32'h1;
      if (_matrixUnit_io_done)
        perfCounters_1 <= perfCounters_1 + 32'h1;
      perfCounters_2 <=
        {27'h0,
         {1'h0,
          {1'h0,
           {1'h0, {1'h0, _macUnits_0_io_valid} + {1'h0, _macUnits_1_io_valid}}
             + {1'h0, {1'h0, _macUnits_2_io_valid} + {1'h0, _macUnits_3_io_valid}}}
            + {1'h0,
               {1'h0, {1'h0, _macUnits_4_io_valid} + {1'h0, _macUnits_5_io_valid}}
                 + {1'h0, {1'h0, _macUnits_6_io_valid} + {1'h0, _macUnits_7_io_valid}}}}
           + {1'h0,
              {1'h0,
               {1'h0, {1'h0, _macUnits_8_io_valid} + {1'h0, _macUnits_9_io_valid}}
                 + {1'h0, {1'h0, _macUnits_10_io_valid} + {1'h0, _macUnits_11_io_valid}}}
                + {1'h0,
                   {1'h0, {1'h0, _macUnits_12_io_valid} + {1'h0, _macUnits_13_io_valid}}
                     + {1'h0,
                        {1'h0, _macUnits_14_io_valid} + {1'h0, _macUnits_15_io_valid}}}}};
      perfCounters_3 <= {16'h0, workCounter};
      if (~axi_state & _GEN & _isMemWrite_T & io_axi_awaddr == 10'h300)
        ctrlReg <= io_axi_wdata;
      statusReg <= {28'h0, macBusy, _matrixUnit_io_done, _matrixUnit_io_busy, ctrlReg[0]};
      axi_state <= ~axi_state & (_GEN | axi_state);
      if (~axi_state & _GEN)
        data_reg <=
          _isMemWrite_T
            ? io_axi_wdata
            : io_axi_araddr == 10'h300
                ? ctrlReg
                : io_axi_araddr == 10'h304
                    ? statusReg
                    : isMatrixARead
                        ? _matrixUnit_io_matrixA_readData
                        : isMatrixBRead
                            ? _matrixUnit_io_matrixB_readData
                            : isResultRead
                                ? _matrixUnit_io_result_readData
                                : isMemRead ? _memoryBlock_ext_R0_data : 32'h0;
      workCounter <= workCounter + 16'h1;
    end
    io_axi_bvalid_REG <= io_axi_awvalid;
    io_axi_rvalid_REG <= io_axi_arvalid;
  end // always @(posedge)
  MacUnit macUnits_0 (
    .clock    (clock),
    .reset    (reset),
    .io_valid (_macUnits_0_io_valid)
  );
  MacUnit macUnits_1 (
    .clock    (clock),
    .reset    (reset),
    .io_valid (_macUnits_1_io_valid)
  );
  MacUnit macUnits_2 (
    .clock    (clock),
    .reset    (reset),
    .io_valid (_macUnits_2_io_valid)
  );
  MacUnit macUnits_3 (
    .clock    (clock),
    .reset    (reset),
    .io_valid (_macUnits_3_io_valid)
  );
  MacUnit macUnits_4 (
    .clock    (clock),
    .reset    (reset),
    .io_valid (_macUnits_4_io_valid)
  );
  MacUnit macUnits_5 (
    .clock    (clock),
    .reset    (reset),
    .io_valid (_macUnits_5_io_valid)
  );
  MacUnit macUnits_6 (
    .clock    (clock),
    .reset    (reset),
    .io_valid (_macUnits_6_io_valid)
  );
  MacUnit macUnits_7 (
    .clock    (clock),
    .reset    (reset),
    .io_valid (_macUnits_7_io_valid)
  );
  MacUnit macUnits_8 (
    .clock    (clock),
    .reset    (reset),
    .io_valid (_macUnits_8_io_valid)
  );
  MacUnit macUnits_9 (
    .clock    (clock),
    .reset    (reset),
    .io_valid (_macUnits_9_io_valid)
  );
  MacUnit macUnits_10 (
    .clock    (clock),
    .reset    (reset),
    .io_valid (_macUnits_10_io_valid)
  );
  MacUnit macUnits_11 (
    .clock    (clock),
    .reset    (reset),
    .io_valid (_macUnits_11_io_valid)
  );
  MacUnit macUnits_12 (
    .clock    (clock),
    .reset    (reset),
    .io_valid (_macUnits_12_io_valid)
  );
  MacUnit macUnits_13 (
    .clock    (clock),
    .reset    (reset),
    .io_valid (_macUnits_13_io_valid)
  );
  MacUnit macUnits_14 (
    .clock    (clock),
    .reset    (reset),
    .io_valid (_macUnits_14_io_valid)
  );
  MacUnit macUnits_15 (
    .clock    (clock),
    .reset    (reset),
    .io_valid (_macUnits_15_io_valid)
  );
  MatrixMultiplier matrixUnit (
    .clock                (clock),
    .reset                (reset),
    .io_start             (ctrlReg[0]),
    .io_busy              (_matrixUnit_io_busy),
    .io_done              (_matrixUnit_io_done),
    .io_matrixA_writeEn   (_isMemWrite_T & io_axi_awaddr < 10'h100),
    .io_matrixA_readEn    (isMatrixARead),
    .io_matrixA_addr      (io_axi_awvalid ? io_axi_awaddr[5:0] : io_axi_araddr[5:0]),
    .io_matrixA_writeData (io_axi_wdata),
    .io_matrixA_readData  (_matrixUnit_io_matrixA_readData),
    .io_matrixB_writeEn   (_isMemWrite_T & (|(io_axi_awaddr[9:8])) & ~(io_axi_awaddr[9])),
    .io_matrixB_readEn    (isMatrixBRead),
    .io_matrixB_addr      (io_axi_awvalid ? io_axi_awaddr[5:0] : io_axi_araddr[5:0]),
    .io_matrixB_writeData (io_axi_wdata),
    .io_matrixB_readData  (_matrixUnit_io_matrixB_readData),
    .io_result_writeEn    (_isMemWrite_T & io_axi_awaddr[9] & io_axi_awaddr[9:8] != 2'h3),
    .io_result_readEn     (isResultRead),
    .io_result_addr       (io_axi_awvalid ? io_axi_awaddr[5:0] : io_axi_araddr[5:0]),
    .io_result_writeData  (io_axi_wdata),
    .io_result_readData   (_matrixUnit_io_result_readData)
  );
  memoryBlock_512x32 memoryBlock_ext (
    .R0_addr (io_axi_araddr[8:0] - 9'h100),
    .R0_en   (isMemRead),
    .R0_clk  (clock),
    .R0_data (_memoryBlock_ext_R0_data),
    .W0_addr (io_axi_awaddr[8:0] - 9'h100),
    .W0_en   (_isMemWrite_T & io_axi_awaddr > 10'h2FF),
    .W0_clk  (clock),
    .W0_data (io_axi_wdata)
  );
  assign io_axi_awready = ~axi_state;
  assign io_axi_wready = ~axi_state;
  assign io_axi_bresp = 2'h0;
  assign io_axi_bvalid = axi_state & io_axi_bvalid_REG;
  assign io_axi_arready = ~axi_state;
  assign io_axi_rdata = data_reg;
  assign io_axi_rvalid = axi_state & io_axi_rvalid_REG;
  assign io_status_busy = io_status_busy_0;
  assign io_status_done = _matrixUnit_io_done;
  assign io_perf_counters_0 = perfCounters_0;
  assign io_perf_counters_1 = perfCounters_1;
  assign io_perf_counters_2 = perfCounters_2;
  assign io_perf_counters_3 = perfCounters_3;
endmodule

